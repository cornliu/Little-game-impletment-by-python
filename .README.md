#Rust Bucket(2018/1/12)
A simple version of Rust Busket. 
##Usage
Run ```python FinalVersion.py``` for starting the game. Make sure you have installed ```pygame``` before.
##Detail
我們在遊戲製作初期先製作純文字版的遊戲，文字版裡面所運用的函數最後也大量的被我們用在後來的圖像化的成品裡。
1.	 利用二維陣列 Board 儲存每個格子的狀態
2.	 將圖片利用pygame讀進程式中，並且放到一個dict中
3.	 寫一些簡單函數編輯陣列內容（如右上圖）：
3.1. InitBoard(n) 宣告一個 n*n 的二維陣列 Board
3.2. ResetBoard() 將Board裡的每個元素還原為初始狀態（以”0”表示）
3.3. PrintBoard() 輸出所有格子的內容物（怪獸或玩家）
4.	寫代表玩家以及怪獸的class：
4.1.參數：
4.1.1. self.pos 代表位置的tuple
4.1.2. self.symbol 輸出代表用的字元 函數：
1. 角色移動及判定(Player/Skull)：上下左右分別要將其對應之格子變為對應的self.symbol，且必須：1. 在其上下左右不在Board內或有障礙物的時候禁止其移動，或是2. 有怪獸的時候將它殺掉。為了可讀性，將移動的部分分為兩個函數，self.Move(move) 以及self.setpos(x, y)，setpos為判定能否將self的新位置設定在第x列第y行的格子內，若可以變進行移動的函數。setpos會確認三件事：欲移動到的位置是否不在Board內（有沒有撞牆），欲移動到的位置上是否有怪獸，以及欲移動到的位置是否有其他障礙物。若以上都沒有便將欲移動到的格子內容改成self.symbol，清除原本的格子，並讓所有怪獸移動。Move 則是依據鍵盤輸入進而呼叫 setpos 將 self 移動至現在格子的上下左右方。
2. 死亡：將所在的格子改回”0”，並輸出 Game Over!，重新設置棋盤
      3.2.怪獸性質及角色移動及判定(Pig/Slime/Octopus):
3.2.1.skull(400 points)：玩家每走一步，skull便會走一步，移動方向為向玩家   最近的方向移動一步，若玩家在其移動的路徑上，他便會像玩家發動攻擊。
3.2.2. slime(100 points)：繼承自skull，移動方向與skull相同，但是每當玩家移動兩步slime才會移動一步。
3.2.3.pig (200 points)：繼承自skull，移動方向與skull想同，但是需要花一步的時間來改變方向，下一步才能朝該方向進行，玩家判定方向的方式為觀察又下角的綠色箭頭。
3.2.4. Octopus(150 points)：繼承自skull，初始方向是向左，他只會向同一個方向前進，當遇到障礙物時便會向反方向進行，若為玩家，則發動攻擊。
       3.3.障礙物說明：
3.3.1.箱子： 同於畫面的邊界，當愈到時只能選擇繞路，無法打破。
	 3.3.1.有裂縫的石頭(-50 points)： 玩家可以花一步的時間將石頭打碎。
5.	怪獸生成 genMobs(n)：在 Board 內 n 個位置任意生成 n 個怪獸
6.	動畫製作（以史萊姆為例）：將 gif 檔分解為 png 檔，匯入一個陣列slime2。利用 pygame.time.wait() 控制迴圈速度，並設置變數 pic_slime ，每一次迴圈在 mod 16 下加一，讀取圖檔時便讀取 slime2 的第 pic_slime 個元素
7.	主程式大概流程：
1.顯示起始畫面及螢幕
2.顯示畫面：畫面是由10*10的小方塊組成，在顯示遊戲介面時會要讀需要顯示的list
(1)	不管list上面的字母為何，都先鋪藍色的磚塊，以製造統一的背景。
(2)	讀上面的每一個字母，從dict中找出該圖片並將他放入正確的位置
	3. 進入每 40 millisecond 跑一次，同時更新動畫的迴圈
4.遊戲進行
(1) 若正在無盡模式，並且已殺死所有怪獸：隨機生成比上次生成數
量加一的怪獸
	(2) 若玩家走到本關終點，儲存分數，並進入下一關
(3) 玩家死亡，若不在無盡模式，從這關開始，分數也恢復至關卡初，若在無盡模式，便從第一關重新
	(4) 若玩家按方向鍵，便執行對應的P.Move
	5.遊戲結束
	顯示所的分數，恭喜玩家

